# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Machina Ludens is an AI creature-breeding game built as a static web app. Players tend a population of AI "bots" that evolve Sokoban puzzle preferences through genetic algorithms. Bots develop heritable taste (genome), curate puzzles for the player, and reproduce based on player ratings — creating a co-evolutionary loop. The theoretical foundation comes from Huizinga's *Homo Ludens* (play produces culture).

## Running the App

No build step or dependencies. Open `index.html` in a browser (or use any static file server). ES modules require serving over HTTP — `python -m http.server` or VS Code Live Server both work. The `prototype/` directory contains an earlier standalone version and is not the active codebase.

## Architecture

**Three-layer module structure** using vanilla ES modules (`<script type="module">`):

- **`shared/`** — Domain logic, no DOM access. Designed to eventually work in both browser and server.
  - `tiles.js` — `TILES` enum (FLOOR=0 through SPIKES=9). Single source of truth for tile types.
  - `generator.js` — `SokobanGenerator` class. Reverse-play algorithm (Taylor & Parberry 2011) with 4 style algorithms: random clusters, recursive subdivision (maze), organic caves (cellular automata), and BSP rooms with internal clusters. Weight-based dispatch selects primary algorithm, then optionally applies a secondary overlay. Includes connectivity enforcement, deadlock detection (corner + freeze), and progressive relaxation on generation failure.
  - `gene-registry.js` — `GENE_REGISTRY` array (20 gene definitions with tier, type, range, mutation params), `TIER_THRESHOLDS` (Primordial/Awakening/Flourishing at 0/50/150 DNA), and tier helper functions. Single source of truth for gene metadata.
  - `solver.js` — Forward BFS solver for Sokoban levels. Verifies solvability by searching normalized (player, boxes) state space. Handles standard pushes, box-ice slides, and exit reachability. Used to validate box-ice levels where reverse-play solvability guarantee breaks down.
  - `entities.js` — Entity system for dynamic objects (patrol enemies). `placePatrolEntities()` places enemies on floor corridors, `advanceEntities()` moves them per turn (bounce at walls/boxes/entities), `checkEntityCollision()` detects player-enemy overlap, `cloneEntities()` for undo snapshots.
  - `genome.js` — `Genome`, `Population`, and `Bot` classes. Genome carries 20 genes across 3 tiers: Tier 1 (structural + style + visual + collectibles = 12), Tier 2 (ice + box-ice + exit = 4), Tier 3 (spikes + patrol = 4). `randomGenes(tier)`, `crossover(p1, p2, tier)`, `mutate(rate, tier)` all respect tier gating. Box-ice levels use solver verification to ensure solvability. Population implements tournament selection, crossover, mutation, elitism, and wild card injection. Bot wraps a Genome with procedurally generated name/personality/colors/sprite and a curation system (affinity-based genome preference).

- **`client/`** — Browser-only UI and game loop.
  - `main.js` — Entry point, creates `Game` instance and exposes it to `window.game` for HTML onclick handlers.
  - `game.js` — `Game` class: canvas rendering, Sokoban movement/undo, keyboard/touch input, breeding workflow, generation history, tier progression, vitality system, spike mechanics, patrol enemy movement/collision, death/extinction, experiment save/load (JSON files), localStorage persistence. Also contains `resolveVisualTheme()` which maps genome visual genes to rendering parameters (colors, shapes, patterns).
  - `levels.js` — 5 hardcoded tutorial levels.

**Key data flow:** `Population` → random bot selected as curator → curator picks genome via affinity → `Bot.generateLevel()` → `Genome.createGenerator()` → `SokobanGenerator.generate()` → player rates → `Population.evolve(fitnessScores)` → next generation.

## Key Design Constraints

- **Grids are always square** (width = height), enforced in `Genome.createGenerator()`.
- **Reverse-play guarantees solvability**: levels are generated by starting from a solved state and pulling boxes away. A forward BFS solver (`shared/solver.js`) exists for mechanics that break the reverse-play guarantee (e.g., box-ice).
- Generator uses progressive relaxation: after many failed attempts it reduces box count, lowers distance thresholds, and eventually falls back to a minimal level.
- All grid operations use flat arrays indexed as `y * width + x`.
- The `TILES` constants are used as raw integers in hot paths (e.g., `grid[nPos] !== 1` instead of `!== TILES.WALL` in `getPlayerReachable`).
- Visual theme is derived from genome at render time — the genome is the single source of truth for both level structure and appearance.
- Population, DNA bank, and vitality persist across page loads via localStorage.

## Docs

- `docs/machina_ludens_gdd.md` — Full game design document
- `ROADMAP.md` — Phase-based development plan with current status
- `EXPERIMENTS.md` / `RESULTS.md` — Cultural divergence experiment notes
- `docs/*.json` — Saved experiment data files
