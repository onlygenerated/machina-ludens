<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machina Ludens - Sokoban Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            margin-bottom: 30px;
            color: #888;
            font-style: italic;
        }

        #game-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        #canvas {
            display: block;
            background: #1a1a1a;
            border: 2px solid #444;
            image-rendering: pixelated;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        #touch-controls {
            display: none;
            margin-top: 20px;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        .dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
        }

        .dpad-btn {
            background: #3a3a3a;
            border: 2px solid #555;
            color: #e0e0e0;
            font-size: 24px;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }

        .dpad-btn:active {
            background: #4a4a4a;
            border-color: #777;
        }

        .dpad-up { grid-column: 2; grid-row: 1; }
        .dpad-down { grid-column: 2; grid-row: 3; }
        .dpad-left { grid-column: 1; grid-row: 2; }
        .dpad-right { grid-column: 3; grid-row: 2; }
        .dpad-center { grid-column: 2; grid-row: 2; opacity: 0; pointer-events: none; }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
            }

            #game-container {
                padding: 15px;
            }

            #touch-controls {
                display: flex;
            }

            button {
                padding: 10px 14px;
                font-size: 0.9em;
            }

            #controls {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }

            .instructions {
                font-size: 0.75em;
            }
        }

        #controls {
            margin-top: 20px;
            text-align: center;
        }

        #breeding-panel {
            display: none;
            margin-top: 30px;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 8px;
            border: 2px solid #444;
        }

        #breeding-panel.active {
            display: block;
        }

        .breeding-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .generation-info {
            color: #888;
            font-size: 0.9em;
        }

        .candidate-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .candidate {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #444;
        }

        .candidate.selected {
            border-color: #4ade80;
        }

        .candidate-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .genome-stats {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 10px;
        }

        .genome-stats div {
            margin: 3px 0;
        }

        .rating {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .star-btn {
            background: #3a3a3a;
            border: 1px solid #555;
            color: #666;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 1.2em;
        }

        .star-btn.active {
            color: #fbbf24;
            background: #4a4a3a;
        }

        .breed-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        #info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #aaa;
        }

        button {
            background: #3a3a3a;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: #4a4a4a;
        }

        button:active {
            background: #2a2a2a;
        }

        #win-message {
            margin-top: 15px;
            font-size: 1.2em;
            color: #4ade80;
            text-align: center;
            min-height: 30px;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <h1>Machina Ludens</h1>
    <div class="subtitle">Sokoban Prototype</div>

    <div id="game-container">
        <div id="info">
            <div>Level: <span id="level-num">1</span></div>
            <div>Moves: <span id="move-count">0</span></div>
            <div>Pushes: <span id="push-count">0</span></div>
        </div>

        <canvas id="canvas" width="480" height="480"></canvas>

        <div id="win-message"></div>

        <div id="touch-controls">
            <div class="dpad">
                <div class="dpad-btn dpad-up" ontouchstart="game.handleTouch(0, -1)" ontouchend="event.preventDefault()">‚¨Ü</div>
                <div class="dpad-btn dpad-left" ontouchstart="game.handleTouch(-1, 0)" ontouchend="event.preventDefault()">‚¨Ö</div>
                <div class="dpad-center"></div>
                <div class="dpad-btn dpad-right" ontouchstart="game.handleTouch(1, 0)" ontouchend="event.preventDefault()">‚û°</div>
                <div class="dpad-btn dpad-down" ontouchstart="game.handleTouch(0, 1)" ontouchend="event.preventDefault()">‚¨á</div>
            </div>
        </div>

        <div id="controls">
            <button onclick="game.undo()">‚Ü∂ Undo</button>
            <button onclick="game.reset()">‚ü≤ Reset</button>
            <button onclick="game.nextLevel()">Next</button>
            <button onclick="game.generateLevel()" style="background: #4a5a3a; border-color: #6a8a5a;">üé≤ Generate</button>
            <button onclick="game.toggleBreedingMode()" style="background: #5a3a5a; border-color: #8a6a8a;">üß¨ Breed</button>
        </div>
    </div>

    <div class="instructions">
        Use Arrow Keys, WASD, or touch controls ‚Ä¢ Push all üì¶ onto üéØ to win
    </div>

    <div id="breeding-panel">
        <div class="breeding-header">
            <h2>üß¨ Evolution Lab</h2>
            <div class="generation-info">
                Generation: <span id="gen-number">0</span>
            </div>
        </div>

        <p style="color: #888; margin-bottom: 20px;">
            Play each level and rate it. Higher-rated genomes will breed to create the next generation.
        </p>

        <div id="candidate-grid" class="candidate-grid">
            <!-- Candidates will be inserted here -->
        </div>

        <div class="breed-controls">
            <button onclick="game.evolvePopulation()">üß¨ Breed Next Generation</button>
            <button onclick="game.toggleBreedingMode()">‚Üê Back to Game</button>
        </div>
    </div>

    <script src="generator.js"></script>
    <script src="genome.js"></script>
    <script>
        // Game constants
        const TILE_SIZE = 60;
        const TILES = {
            FLOOR: 0,
            WALL: 1,
            TARGET: 2,
            BOX: 3,
            PLAYER: 4,
            BOX_ON_TARGET: 5
        };

        // Emoji rendering
        const EMOJI = {
            [TILES.FLOOR]: '‚¨õ',
            [TILES.WALL]: 'üü´',
            [TILES.TARGET]: 'üéØ',
            [TILES.BOX]: 'üì¶',
            [TILES.PLAYER]: 'üë§',
            [TILES.BOX_ON_TARGET]: '‚úÖ'
        };

        // Level data (1 = wall, 0 = floor, 2 = target, 3 = box, 4 = player)
        const LEVELS = [
            // Level 1: Tutorial
            {
                width: 7,
                height: 7,
                grid: [
                    1,1,1,1,1,1,1,
                    1,0,0,0,0,0,1,
                    1,0,0,3,0,0,1,
                    1,0,0,0,0,0,1,
                    1,0,4,0,2,0,1,
                    1,0,0,0,0,0,1,
                    1,1,1,1,1,1,1
                ]
            },
            // Level 2: Two boxes
            {
                width: 8,
                height: 7,
                grid: [
                    1,1,1,1,1,1,1,1,
                    1,0,0,0,0,0,0,1,
                    1,0,3,0,0,3,0,1,
                    1,0,0,0,0,0,0,1,
                    1,0,2,0,0,2,0,1,
                    1,0,0,4,0,0,0,1,
                    1,1,1,1,1,1,1,1
                ]
            },
            // Level 3: Corridor
            {
                width: 9,
                height: 5,
                grid: [
                    1,1,1,1,1,1,1,1,1,
                    1,4,0,3,0,3,0,0,1,
                    1,0,0,0,0,0,2,2,1,
                    1,0,0,0,0,0,0,0,1,
                    1,1,1,1,1,1,1,1,1
                ]
            },
            // Level 4: Classic puzzle
            {
                width: 7,
                height: 7,
                grid: [
                    1,1,1,1,1,1,1,
                    1,0,0,0,0,0,1,
                    1,0,3,1,3,0,1,
                    1,0,0,4,0,0,1,
                    1,0,2,1,2,0,1,
                    1,0,0,0,0,0,1,
                    1,1,1,1,1,1,1
                ]
            },
            // Level 5: Tight corners
            {
                width: 8,
                height: 8,
                grid: [
                    1,1,1,1,1,1,1,1,
                    1,2,0,0,0,0,2,1,
                    1,0,1,1,1,1,0,1,
                    1,0,1,0,0,1,0,1,
                    1,0,1,0,0,1,0,1,
                    1,0,1,1,1,1,0,1,
                    1,3,0,4,0,0,3,1,
                    1,1,1,1,1,1,1,1
                ]
            }
        ];

        // Game state
        class Game {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentLevel = 0;
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;

                // Breeding mode state
                this.breedingMode = false;
                this.population = null;
                this.candidates = [];
                this.ratings = [];

                this.loadLevel(0);
                this.setupControls();
                this.setupTouchGestures();
                this.render();
            }

            handleTouch(dx, dy) {
                if (this.won) return;
                this.move(dx, dy);
            }

            setupTouchGestures() {
                let touchStartX = 0;
                let touchStartY = 0;
                const minSwipeDistance = 30;

                this.canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    e.preventDefault();
                }, { passive: false });

                this.canvas.addEventListener('touchend', (e) => {
                    if (this.won) return;

                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;

                    const absX = Math.abs(deltaX);
                    const absY = Math.abs(deltaY);

                    if (absX < minSwipeDistance && absY < minSwipeDistance) {
                        return;
                    }

                    if (absX > absY) {
                        this.move(deltaX > 0 ? 1 : -1, 0);
                    } else {
                        this.move(0, deltaY > 0 ? 1 : -1);
                    }

                    e.preventDefault();
                }, { passive: false });
            }

            loadLevel(levelNum) {
                if (levelNum >= LEVELS.length) {
                    this.showWin("üéâ All levels complete! üéâ");
                    return;
                }

                this.currentLevel = levelNum;
                const level = LEVELS[levelNum];
                this.width = level.width;
                this.height = level.height;
                this.grid = [...level.grid];
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;

                // Find player position
                const playerIdx = this.grid.indexOf(TILES.PLAYER);
                this.playerX = playerIdx % this.width;
                this.playerY = Math.floor(playerIdx / this.width);

                // Update canvas size
                this.canvas.width = this.width * TILE_SIZE;
                this.canvas.height = this.height * TILE_SIZE;

                this.updateUI();
                this.render();
            }

            reset() {
                this.loadLevel(this.currentLevel);
            }

            nextLevel() {
                this.loadLevel(this.currentLevel + 1);
            }

            generateLevel() {
                // Create a new procedurally generated level with random parameters
                const generatedLevel = SokobanGenerator.generateRandom();

                // Load it as a custom level
                this.currentLevel = -1; // Mark as generated
                this.width = generatedLevel.width;
                this.height = generatedLevel.height;
                this.grid = generatedLevel.grid;
                this.playerX = generatedLevel.playerX;
                this.playerY = generatedLevel.playerY;
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;

                // Update canvas size
                this.canvas.width = this.width * TILE_SIZE;
                this.canvas.height = this.height * TILE_SIZE;

                this.updateUI();
                this.render();
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.won) return;

                    const key = e.key.toLowerCase();

                    if (key === 'z') {
                        this.undo();
                        e.preventDefault();
                    } else if (key === 'r') {
                        this.reset();
                        e.preventDefault();
                    } else if (key === 'n') {
                        this.nextLevel();
                        e.preventDefault();
                    } else {
                        const moves = {
                            'arrowup': [0, -1],
                            'arrowdown': [0, 1],
                            'arrowleft': [-1, 0],
                            'arrowright': [1, 0],
                            'w': [0, -1],
                            's': [0, 1],
                            'a': [-1, 0],
                            'd': [1, 0]
                        };

                        if (moves[key]) {
                            this.move(...moves[key]);
                            e.preventDefault();
                        }
                    }
                });
            }

            move(dx, dy) {
                const newX = this.playerX + dx;
                const newY = this.playerY + dy;

                if (!this.isValid(newX, newY)) return;

                const targetTile = this.getTile(newX, newY);

                // Hit a wall
                if (targetTile === TILES.WALL) return;

                // Save state for undo
                this.saveState();

                // Check if pushing a box
                if (targetTile === TILES.BOX || targetTile === TILES.BOX_ON_TARGET) {
                    const boxNewX = newX + dx;
                    const boxNewY = newY + dy;

                    if (!this.isValid(boxNewX, boxNewY)) return;

                    const boxTargetTile = this.getTile(boxNewX, boxNewY);

                    // Can't push into wall or another box
                    if (boxTargetTile === TILES.WALL ||
                        boxTargetTile === TILES.BOX ||
                        boxTargetTile === TILES.BOX_ON_TARGET) {
                        this.history.pop(); // Undo the save
                        return;
                    }

                    // Move the box
                    const isOnTarget = boxTargetTile === TILES.TARGET;
                    this.setTile(boxNewX, boxNewY, isOnTarget ? TILES.BOX_ON_TARGET : TILES.BOX);
                    this.pushes++;
                }

                // Clear old player position (restore target if needed)
                const wasOnTarget = this.getTile(this.playerX, this.playerY) === TILES.TARGET;
                this.setTile(this.playerX, this.playerY, wasOnTarget ? TILES.TARGET : TILES.FLOOR);

                // Clear box from new player position if present
                const movingToTarget = targetTile === TILES.TARGET || targetTile === TILES.BOX_ON_TARGET;

                // Move player
                this.playerX = newX;
                this.playerY = newY;
                this.setTile(newX, newY, movingToTarget ? TILES.TARGET : TILES.FLOOR);

                this.moves++;
                this.updateUI();
                this.render();
                this.checkWin();
            }

            undo() {
                if (this.history.length === 0) return;

                const state = this.history.pop();
                this.grid = state.grid;
                this.playerX = state.playerX;
                this.playerY = state.playerY;
                this.moves = state.moves;
                this.pushes = state.pushes;

                this.updateUI();
                this.render();
            }

            saveState() {
                this.history.push({
                    grid: [...this.grid],
                    playerX: this.playerX,
                    playerY: this.playerY,
                    moves: this.moves,
                    pushes: this.pushes
                });
            }

            isValid(x, y) {
                return x >= 0 && x < this.width && y >= 0 && y < this.height;
            }

            getTile(x, y) {
                return this.grid[y * this.width + x];
            }

            setTile(x, y, tile) {
                this.grid[y * this.width + x] = tile;
            }

            checkWin() {
                // Check if all boxes are on targets
                const hasLooseBox = this.grid.some(tile => tile === TILES.BOX);

                if (!hasLooseBox) {
                    this.won = true;
                    this.showWin("Level Complete! üéâ");
                }
            }

            showWin(message) {
                document.getElementById('win-message').textContent = message;
            }

            updateUI() {
                const levelText = this.currentLevel === -1 ? 'Generated' : this.currentLevel + 1;
                document.getElementById('level-num').textContent = levelText;
                document.getElementById('move-count').textContent = this.moves;
                document.getElementById('push-count').textContent = this.pushes;
                document.getElementById('win-message').textContent = '';
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.font = `${TILE_SIZE - 10}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';

                // Draw grid
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.getTile(x, y);
                        const emoji = EMOJI[tile];

                        const px = x * TILE_SIZE + TILE_SIZE / 2;
                        const py = y * TILE_SIZE + TILE_SIZE / 2;

                        this.ctx.fillText(emoji, px, py);
                    }
                }

                // Draw player on top
                const px = this.playerX * TILE_SIZE + TILE_SIZE / 2;
                const py = this.playerY * TILE_SIZE + TILE_SIZE / 2;
                this.ctx.fillText(EMOJI[TILES.PLAYER], px, py);
            }

            // === BREEDING MODE METHODS ===

            toggleBreedingMode() {
                const gameContainer = document.getElementById('game-container');
                const breedingPanel = document.getElementById('breeding-panel');

                // If we're currently showing the breeding panel, go back to game
                if (breedingPanel.classList.contains('active')) {
                    this.breedingMode = false;
                    gameContainer.style.display = 'block';
                    breedingPanel.classList.remove('active');
                } else {
                    // Switch to breeding mode
                    this.breedingMode = true;

                    // Initialize population if needed
                    if (!this.population) {
                        this.population = new Population(5); // Start with 5 genomes
                    }

                    // Show breeding panel, hide game
                    gameContainer.style.display = 'none';
                    breedingPanel.classList.add('active');

                    this.displayCandidates();
                }
            }

            displayCandidates() {
                const grid = document.getElementById('candidate-grid');
                const genNumber = document.getElementById('gen-number');

                genNumber.textContent = this.population.generation;

                const genomes = this.population.getCurrentGeneration();
                this.candidates = [];
                this.ratings = new Array(genomes.length).fill(0);

                grid.innerHTML = '';

                genomes.forEach((genome, index) => {
                    const candidate = document.createElement('div');
                    candidate.className = 'candidate';
                    candidate.id = `candidate-${index}`;

                    const stats = genome.describe();
                    const statsHTML = Object.entries(stats)
                        .map(([key, val]) => `<div>${key}: ${val}</div>`)
                        .join('');

                    candidate.innerHTML = `
                        <div class="candidate-header">
                            <strong>Genome ${index + 1}</strong>
                        </div>
                        <div class="genome-stats">
                            ${statsHTML}
                        </div>
                        <button onclick="game.playCandidate(${index})">‚ñ∂ Play Level</button>
                        <div class="rating">
                            ${[1, 2, 3, 4, 5].map(star =>
                                `<button class="star-btn" onclick="game.rateCandidate(${index}, ${star})">‚òÖ</button>`
                            ).join('')}
                        </div>
                    `;

                    grid.appendChild(candidate);
                    this.candidates.push({ genome, element: candidate });
                });
            }

            playCandidate(index) {
                const genome = this.candidates[index].genome;

                // Generate level from this genome
                const level = genome.generateLevel();

                // Switch to game view temporarily (keep breedingMode true)
                document.getElementById('game-container').style.display = 'block';
                document.getElementById('breeding-panel').classList.remove('active');

                // Load the generated level
                this.currentLevel = -1;
                this.width = level.width;
                this.height = level.height;
                this.grid = level.grid;
                this.playerX = level.playerX;
                this.playerY = level.playerY;
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;

                this.canvas.width = this.width * TILE_SIZE;
                this.canvas.height = this.height * TILE_SIZE;

                this.updateUI();
                this.render();

                // Show message
                this.showWin(`Playing Genome ${index + 1} - Press üß¨ Breed to return`);
            }

            rateCandidate(index, rating) {
                this.ratings[index] = rating;

                // Update star buttons
                const candidate = document.getElementById(`candidate-${index}`);
                const stars = candidate.querySelectorAll('.star-btn');

                stars.forEach((star, i) => {
                    if (i < rating) {
                        star.classList.add('active');
                    } else {
                        star.classList.remove('active');
                    }
                });

                candidate.classList.add('selected');
            }

            evolvePopulation() {
                // Check if all candidates have been rated
                const unrated = this.ratings.filter(r => r === 0).length;
                if (unrated > 0) {
                    alert(`Please rate all ${unrated} remaining level(s) before breeding!`);
                    return;
                }

                // Evolve to next generation
                this.population.evolve(this.ratings);

                // Show stats
                const stats = this.population.getStats();
                console.log('Population Stats:', stats);

                // Display new generation
                this.displayCandidates();

                // Show notification
                alert(`Generation ${this.population.generation} created!\n\nAvg Grid Size: ${stats.averages.gridSize}\nAvg Boxes: ${stats.averages.boxCount}\nAvg Complexity: ${stats.averages.complexity}\nAvg Wall Density: ${stats.averages.wallDensity}`);
            }
        }

        // Initialize game
        const game = new Game();
    </script>
</body>
</html>
