<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machina Ludens - Sokoban Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            margin-bottom: 30px;
            color: #888;
            font-style: italic;
        }

        #game-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        #canvas {
            display: block;
            background: #1a1a1a;
            border: 2px solid #444;
            image-rendering: pixelated;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        #touch-controls {
            display: none;
            margin-top: 20px;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        .dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
        }

        .dpad-btn {
            background: #3a3a3a;
            border: 2px solid #555;
            color: #e0e0e0;
            font-size: 24px;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }

        .dpad-btn:active {
            background: #4a4a4a;
            border-color: #777;
        }

        .dpad-up { grid-column: 2; grid-row: 1; }
        .dpad-down { grid-column: 2; grid-row: 3; }
        .dpad-left { grid-column: 1; grid-row: 2; }
        .dpad-right { grid-column: 3; grid-row: 2; }
        .dpad-center { grid-column: 2; grid-row: 2; opacity: 0; pointer-events: none; }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
            }

            #game-container {
                padding: 15px;
            }

            #touch-controls {
                display: flex;
            }

            button {
                padding: 10px 14px;
                font-size: 0.9em;
            }

            #controls {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }

            .instructions {
                font-size: 0.75em;
            }
        }

        #controls {
            margin-top: 20px;
            text-align: center;
        }

        .star-btn {
            background: #3a3a3a;
            border: 1px solid #555;
            color: #666;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 1.2em;
        }

        .star-btn.active {
            color: #fbbf24;
            background: #4a4a3a;
        }

        #info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #aaa;
        }

        #rating-panel {
            margin-top: 15px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 6px;
            border: 1px solid #444;
        }

        #rating-panel h3 {
            margin: 0 0 10px 0;
            font-size: 0.9em;
            color: #888;
            text-align: center;
        }

        .rating-stars {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 10px;
        }

        .rating-stars .star-btn {
            font-size: 1.5em;
            padding: 8px 12px;
        }

        #generation-display {
            text-align: center;
            color: #666;
            font-size: 0.85em;
            margin-top: 10px;
        }

        #breed-btn {
            display: none;
            margin-top: 10px;
            background: #5a3a5a;
            border-color: #8a6a8a;
        }

        #breed-btn.visible {
            display: inline-block;
        }

        button {
            background: #3a3a3a;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: #4a4a4a;
        }

        button:active {
            background: #2a2a2a;
        }

        #win-message {
            margin-top: 15px;
            font-size: 1.2em;
            color: #4ade80;
            text-align: center;
            min-height: 30px;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <h1>Machina Ludens</h1>
    <div class="subtitle">Sokoban Prototype</div>

    <div id="game-container">
        <div id="info">
            <div>Level: <span id="level-num">1</span></div>
            <div>Moves: <span id="move-count">0</span></div>
            <div>Pushes: <span id="push-count">0</span></div>
        </div>

        <canvas id="canvas" width="480" height="480"></canvas>

        <div id="win-message"></div>

        <div id="touch-controls">
            <div class="dpad">
                <div class="dpad-btn dpad-up" ontouchstart="game.handleTouch(0, -1)" ontouchend="event.preventDefault()">‚¨Ü</div>
                <div class="dpad-btn dpad-left" ontouchstart="game.handleTouch(-1, 0)" ontouchend="event.preventDefault()">‚¨Ö</div>
                <div class="dpad-center"></div>
                <div class="dpad-btn dpad-right" ontouchstart="game.handleTouch(1, 0)" ontouchend="event.preventDefault()">‚û°</div>
                <div class="dpad-btn dpad-down" ontouchstart="game.handleTouch(0, 1)" ontouchend="event.preventDefault()">‚¨á</div>
            </div>
        </div>

        <div id="controls">
            <button onclick="game.undo()">‚Ü∂ Undo</button>
            <button onclick="game.reset()">‚ü≤ Reset</button>
            <button onclick="game.generateLevel()" style="background: #4a5a3a; border-color: #6a8a5a;">üé≤ Generate</button>
        </div>

        <div id="experiment-controls" style="margin-top: 15px; text-align: center; border-top: 1px solid #444; padding-top: 15px;">
            <div style="margin-bottom: 10px; color: #888; font-size: 0.85em;">Experiment Tools</div>
            <button onclick="game.toggleHistoryView()" style="background: #3a4a5a; border-color: #5a6a7a;">üìä View History</button>
            <button onclick="game.exportHistory()" style="background: #3a5a4a; border-color: #5a7a6a;">üíæ Export Data</button>
            <button onclick="game.saveExperiment()" style="background: #4a3a5a; border-color: #6a5a7a;">üíæ Save Experiment</button>
            <button onclick="document.getElementById('load-file').click()" style="background: #3a5a5a; border-color: #5a7a7a;">üìÇ Load Experiment</button>
            <button onclick="game.clearState()" style="background: #5a3a3a; border-color: #7a5a5a;">üóëÔ∏è Clear & Restart</button>
            <input type="file" id="load-file" accept=".json" style="display: none;" onchange="game.loadExperiment(event)">
        </div>

        <div id="history-view" style="display: none; margin-top: 15px; padding: 15px; background: #1a1a1a; border-radius: 6px; max-height: 300px; overflow-y: auto;">
            <h3 style="margin: 0 0 10px 0; font-size: 1em; color: #aaa;">Generation History</h3>
            <div id="history-content"></div>
        </div>

        <div id="win-message"></div>

        <div id="rating-panel">
            <div id="bot-presentation" style="text-align: center; margin-bottom: 15px;">
                <p id="curator-info" style="margin: 5px 0 10px 0; color: #666; font-size: 0.85em;">
                    <span id="curator-name">-</span> presents:
                </p>
                <canvas id="bot-sprite" width="80" height="80" style="display: block; margin: 10px auto; border-radius: 50%; background: #1a1a1a;"></canvas>
                <h3 id="bot-name" style="margin: 5px 0; color: #e0e0e0; font-size: 1.1em;">-</h3>
                <p id="bot-personality" style="margin: 5px 0; color: #888; font-size: 0.85em; font-style: italic;">-</p>
                <p style="margin: 10px 0 5px 0; color: #666; font-size: 0.9em;">Rate this puzzle:</p>
            </div>
            <div class="rating-stars">
                <button class="star-btn" onclick="game.rateCurrentLevel(1)">‚òÖ</button>
                <button class="star-btn" onclick="game.rateCurrentLevel(2)">‚òÖ</button>
                <button class="star-btn" onclick="game.rateCurrentLevel(3)">‚òÖ</button>
                <button class="star-btn" onclick="game.rateCurrentLevel(4)">‚òÖ</button>
                <button class="star-btn" onclick="game.rateCurrentLevel(5)">‚òÖ</button>
            </div>
            <div id="generation-display">Generation: 0 | Rated: 0</div>
            <div id="population-stats" style="margin-top: 10px; padding: 8px; background: #1a1a1a; border-radius: 4px; font-size: 0.8em; color: #888; text-align: center; display: none;">
                Population Avg: Grid: - | Boxes: - | Complexity: - | Density: -
            </div>
            <div id="curation-stats" style="margin-top: 10px; padding: 8px; background: #1a1a1a; border-radius: 4px; font-size: 0.75em; color: #666; text-align: center; display: none;">
                Curation: - selections | Avg affinity: -
            </div>
            <div style="text-align: center;">
                <button id="breed-btn" onclick="game.breedNextGeneration()">üß¨ Breed Next Generation</button>
            </div>
        </div>
    </div>

    <div class="instructions">
        Use Arrow Keys, WASD, or touch controls ‚Ä¢ Push all boxes onto targets to win
    </div>

    <script src="generator.js"></script>
    <script src="genome.js"></script>
    <script>
        // Game constants
        const TILE_SIZE = 60;
        const TILES = {
            FLOOR: 0,
            WALL: 1,
            TARGET: 2,
            BOX: 3,
            PLAYER: 4,
            BOX_ON_TARGET: 5
        };

        // Color-based rendering
        const COLORS = {
            FLOOR: '#1a1a2e',
            WALL: '#8B4513',
            WALL_LIGHT: '#A0522D',
            WALL_DARK: '#5C2E0A',
            TARGET: '#E74C3C',
            BOX: '#DAA520',
            BOX_BORDER: '#B8860B',
            PLAYER: '#4ECDC4',
            BOX_ON_TARGET: '#4CAF50',
            BOX_ON_TARGET_BORDER: '#388E3C'
        };

        // Level data (1 = wall, 0 = floor, 2 = target, 3 = box, 4 = player)
        const LEVELS = [
            // Level 1: Tutorial
            {
                width: 7,
                height: 7,
                grid: [
                    1,1,1,1,1,1,1,
                    1,0,0,0,0,0,1,
                    1,0,0,3,0,0,1,
                    1,0,0,0,0,0,1,
                    1,0,4,0,2,0,1,
                    1,0,0,0,0,0,1,
                    1,1,1,1,1,1,1
                ]
            },
            // Level 2: Two boxes
            {
                width: 8,
                height: 7,
                grid: [
                    1,1,1,1,1,1,1,1,
                    1,0,0,0,0,0,0,1,
                    1,0,3,0,0,3,0,1,
                    1,0,0,0,0,0,0,1,
                    1,0,2,0,0,2,0,1,
                    1,0,0,4,0,0,0,1,
                    1,1,1,1,1,1,1,1
                ]
            },
            // Level 3: Corridor
            {
                width: 9,
                height: 5,
                grid: [
                    1,1,1,1,1,1,1,1,1,
                    1,4,0,3,0,3,0,0,1,
                    1,0,0,0,0,0,2,2,1,
                    1,0,0,0,0,0,0,0,1,
                    1,1,1,1,1,1,1,1,1
                ]
            },
            // Level 4: Classic puzzle
            {
                width: 7,
                height: 7,
                grid: [
                    1,1,1,1,1,1,1,
                    1,0,0,0,0,0,1,
                    1,0,3,1,3,0,1,
                    1,0,0,4,0,0,1,
                    1,0,2,1,2,0,1,
                    1,0,0,0,0,0,1,
                    1,1,1,1,1,1,1
                ]
            },
            // Level 5: Tight corners
            {
                width: 8,
                height: 8,
                grid: [
                    1,1,1,1,1,1,1,1,
                    1,2,0,0,0,0,2,1,
                    1,0,1,1,1,1,0,1,
                    1,0,1,0,0,1,0,1,
                    1,0,1,0,0,1,0,1,
                    1,0,1,1,1,1,0,1,
                    1,3,0,4,0,0,3,1,
                    1,1,1,1,1,1,1,1
                ]
            }
        ];

        // Game state
        class Game {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentLevel = 0;
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;

                // Breeding mode state
                this.population = new Population(5); // Start with initial population
                this.currentBot = null; // Currently playing bot
                this.curatorBot = null; // Bot who curated/selected this level
                this.ratedBots = []; // Track rated bots with their scores
                this.currentLevelRating = 0;
                this.generationHistory = []; // Track stats over generations
                this.curationStats = []; // Track curator choices

                // Load saved state if available
                this.loadState();

                this.setupControls();
                this.setupTouchGestures();

                // Generate first level automatically
                this.generateLevel();
            }

            handleTouch(dx, dy) {
                if (this.won) return;
                this.move(dx, dy);
            }

            setupTouchGestures() {
                let touchStartX = 0;
                let touchStartY = 0;
                const minSwipeDistance = 30;

                this.canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    e.preventDefault();
                }, { passive: false });

                this.canvas.addEventListener('touchend', (e) => {
                    if (this.won) return;

                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;

                    const absX = Math.abs(deltaX);
                    const absY = Math.abs(deltaY);

                    if (absX < minSwipeDistance && absY < minSwipeDistance) {
                        return;
                    }

                    if (absX > absY) {
                        this.move(deltaX > 0 ? 1 : -1, 0);
                    } else {
                        this.move(0, deltaY > 0 ? 1 : -1);
                    }

                    e.preventDefault();
                }, { passive: false });
            }

            loadLevel(levelNum) {
                if (levelNum >= LEVELS.length) {
                    this.showWin("üéâ All levels complete! üéâ");
                    return;
                }

                this.currentLevel = levelNum;
                const level = LEVELS[levelNum];
                this.width = level.width;
                this.height = level.height;
                this.grid = [...level.grid];
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;

                // Find player position
                const playerIdx = this.grid.indexOf(TILES.PLAYER);
                this.playerX = playerIdx % this.width;
                this.playerY = Math.floor(playerIdx / this.width);

                // Update canvas size
                this.canvas.width = this.width * TILE_SIZE;
                this.canvas.height = this.height * TILE_SIZE;

                this.updateUI();
                this.render();
            }

            reset() {
                // If it's a generated level, reset to saved state
                if (this.currentLevel === -1 && this.generatedLevelData) {
                    const level = this.generatedLevelData;
                    this.width = level.width;
                    this.height = level.height;
                    this.grid = [...level.grid]; // Copy the grid
                    this.playerX = level.playerX;
                    this.playerY = level.playerY;
                    this.moves = 0;
                    this.pushes = 0;
                    this.history = [];
                    this.won = false;

                    this.canvas.width = this.width * TILE_SIZE;
                    this.canvas.height = this.height * TILE_SIZE;

                    this.updateUI();
                    this.render();
                } else {
                    // Regular level from LEVELS array
                    this.loadLevel(this.currentLevel);
                }
            }

            nextLevel() {
                this.loadLevel(this.currentLevel + 1);
            }

            generateLevel() {
                const genomes = this.population.getCurrentGeneration();

                // Pick a random bot to be the curator
                const curatorGenome = genomes[Math.floor(Math.random() * genomes.length)];
                this.curatorBot = new Bot(curatorGenome);

                // Curator evaluates all genomes and picks their favorite
                const curationResult = this.curatorBot.curate(genomes);
                const chosenGenome = curationResult.genome;
                const affinity = curationResult.affinity;

                // Create bot for the chosen genome
                this.currentBot = new Bot(chosenGenome);

                // Track curation decision
                this.curationStats.push({
                    curator: this.curatorBot.name,
                    creator: this.currentBot.name,
                    affinity: affinity,
                    generation: this.population.generation
                });

                // Generate level from chosen genome
                const generatedLevel = this.currentBot.generateLevel();

                // Save the generated level data for reset functionality
                this.generatedLevelData = {
                    width: generatedLevel.width,
                    height: generatedLevel.height,
                    grid: [...generatedLevel.grid], // Copy the grid
                    playerX: generatedLevel.playerX,
                    playerY: generatedLevel.playerY
                };

                // Load it as a custom level
                this.currentLevel = -1; // Mark as generated
                this.width = generatedLevel.width;
                this.height = generatedLevel.height;
                this.grid = generatedLevel.grid;
                this.playerX = generatedLevel.playerX;
                this.playerY = generatedLevel.playerY;
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;
                this.currentLevelRating = 0;

                // Update canvas size
                this.canvas.width = this.width * TILE_SIZE;
                this.canvas.height = this.height * TILE_SIZE;

                this.updateUI();
                this.render();
                this.updateRatingDisplay();
                this.updateBotDisplay();
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.won) return;

                    const key = e.key.toLowerCase();

                    if (key === 'z') {
                        this.undo();
                        e.preventDefault();
                    } else if (key === 'r') {
                        this.reset();
                        e.preventDefault();
                    } else if (key === 'n') {
                        this.nextLevel();
                        e.preventDefault();
                    } else {
                        const moves = {
                            'arrowup': [0, -1],
                            'arrowdown': [0, 1],
                            'arrowleft': [-1, 0],
                            'arrowright': [1, 0],
                            'w': [0, -1],
                            's': [0, 1],
                            'a': [-1, 0],
                            'd': [1, 0]
                        };

                        if (moves[key]) {
                            this.move(...moves[key]);
                            e.preventDefault();
                        }
                    }
                });
            }

            move(dx, dy) {
                const newX = this.playerX + dx;
                const newY = this.playerY + dy;

                if (!this.isValid(newX, newY)) return;

                const targetTile = this.getTile(newX, newY);

                // Hit a wall
                if (targetTile === TILES.WALL) return;

                // Save state for undo
                this.saveState();

                // Check if pushing a box
                if (targetTile === TILES.BOX || targetTile === TILES.BOX_ON_TARGET) {
                    const boxNewX = newX + dx;
                    const boxNewY = newY + dy;

                    if (!this.isValid(boxNewX, boxNewY)) {
                        this.history.pop(); // Undo the save
                        return;
                    }

                    const boxTargetTile = this.getTile(boxNewX, boxNewY);

                    // Can't push into wall or another box
                    if (boxTargetTile === TILES.WALL ||
                        boxTargetTile === TILES.BOX ||
                        boxTargetTile === TILES.BOX_ON_TARGET) {
                        this.history.pop(); // Undo the save
                        return;
                    }

                    // Move the box
                    const isOnTarget = boxTargetTile === TILES.TARGET;
                    this.setTile(boxNewX, boxNewY, isOnTarget ? TILES.BOX_ON_TARGET : TILES.BOX);
                    this.pushes++;
                }

                // Clear old player position (restore target if needed)
                const wasOnTarget = this.getTile(this.playerX, this.playerY) === TILES.TARGET;
                this.setTile(this.playerX, this.playerY, wasOnTarget ? TILES.TARGET : TILES.FLOOR);

                // Clear box from new player position if present
                const movingToTarget = targetTile === TILES.TARGET || targetTile === TILES.BOX_ON_TARGET;

                // Move player
                this.playerX = newX;
                this.playerY = newY;
                this.setTile(newX, newY, movingToTarget ? TILES.TARGET : TILES.FLOOR);

                this.moves++;
                this.updateUI();
                this.render();
                this.checkWin();
            }

            undo() {
                if (this.history.length === 0) return;

                const state = this.history.pop();
                this.grid = [...state.grid]; // Make sure to copy the array
                this.playerX = state.playerX;
                this.playerY = state.playerY;
                this.moves = state.moves;
                this.pushes = state.pushes;
                this.won = false; // Reset win state when undoing

                this.updateUI();
                this.render();

                // Clear win message
                document.getElementById('win-message').textContent = '';
            }

            saveState() {
                this.history.push({
                    grid: [...this.grid],
                    playerX: this.playerX,
                    playerY: this.playerY,
                    moves: this.moves,
                    pushes: this.pushes
                });
            }

            isValid(x, y) {
                return x >= 0 && x < this.width && y >= 0 && y < this.height;
            }

            getTile(x, y) {
                return this.grid[y * this.width + x];
            }

            setTile(x, y, tile) {
                this.grid[y * this.width + x] = tile;
            }

            checkWin() {
                // Check if all boxes are on targets
                const hasLooseBox = this.grid.some(tile => tile === TILES.BOX);

                if (!hasLooseBox) {
                    this.won = true;
                    this.showWin("Level Complete! üéâ");
                }
            }

            showWin(message) {
                document.getElementById('win-message').textContent = message;
            }

            updateUI() {
                const levelText = this.currentLevel === -1 ? 'Generated' : this.currentLevel + 1;
                document.getElementById('level-num').textContent = levelText;
                document.getElementById('move-count').textContent = this.moves;
                document.getElementById('push-count').textContent = this.pushes;
                document.getElementById('win-message').textContent = '';
            }

            render() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const ts = TILE_SIZE;
                const pad = Math.max(1, ts * 0.06); // padding for borders

                // Draw grid
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.getTile(x, y);
                        const px = x * ts;
                        const py = y * ts;

                        // Floor background for every tile
                        ctx.fillStyle = COLORS.FLOOR;
                        ctx.fillRect(px, py, ts, ts);

                        if (tile === TILES.WALL) {
                            // 3D-style wall
                            ctx.fillStyle = COLORS.WALL_LIGHT;
                            ctx.fillRect(px, py, ts, ts);
                            ctx.fillStyle = COLORS.WALL;
                            ctx.fillRect(px + pad, py + pad, ts - pad, ts - pad);
                            ctx.fillStyle = COLORS.WALL_DARK;
                            ctx.fillRect(px + pad, py + ts - pad, ts - pad, pad);
                            ctx.fillRect(px + ts - pad, py + pad, pad, ts - pad);
                        } else if (tile === TILES.TARGET) {
                            // Diamond/marker on floor
                            ctx.fillStyle = COLORS.TARGET;
                            const cx = px + ts / 2;
                            const cy = py + ts / 2;
                            const r = ts * 0.2;
                            ctx.beginPath();
                            ctx.moveTo(cx, cy - r);
                            ctx.lineTo(cx + r, cy);
                            ctx.lineTo(cx, cy + r);
                            ctx.lineTo(cx - r, cy);
                            ctx.closePath();
                            ctx.fill();
                        } else if (tile === TILES.BOX) {
                            // Amber box with border
                            ctx.fillStyle = COLORS.BOX_BORDER;
                            ctx.fillRect(px + pad, py + pad, ts - pad * 2, ts - pad * 2);
                            ctx.fillStyle = COLORS.BOX;
                            ctx.fillRect(px + pad * 3, py + pad * 3, ts - pad * 6, ts - pad * 6);
                        } else if (tile === TILES.BOX_ON_TARGET) {
                            // Green box with border
                            ctx.fillStyle = COLORS.BOX_ON_TARGET_BORDER;
                            ctx.fillRect(px + pad, py + pad, ts - pad * 2, ts - pad * 2);
                            ctx.fillStyle = COLORS.BOX_ON_TARGET;
                            ctx.fillRect(px + pad * 3, py + pad * 3, ts - pad * 6, ts - pad * 6);
                        }
                        // FLOOR: already drawn as background
                    }
                }

                // Draw player on top as a circle
                const pcx = this.playerX * ts + ts / 2;
                const pcy = this.playerY * ts + ts / 2;
                const pr = ts * 0.35;
                ctx.fillStyle = COLORS.PLAYER;
                ctx.beginPath();
                ctx.arc(pcx, pcy, pr, 0, Math.PI * 2);
                ctx.fill();
            }

            // === BREEDING MODE METHODS ===

            rateCurrentLevel(rating) {
                if (!this.currentBot) {
                    alert('Generate a level first!');
                    return;
                }

                this.currentLevelRating = rating;

                // Store this rating (store genome for breeding compatibility)
                this.ratedBots.push({
                    bot: this.currentBot,
                    genome: this.currentBot.genome,
                    rating: rating
                });

                // Update star display
                this.updateRatingDisplay();

                // Update generation display
                this.updateGenerationDisplay();

                // Show breed button if we have enough ratings
                if (this.ratedBots.length >= 3) {
                    document.getElementById('breed-btn').classList.add('visible');
                }
            }

            updateRatingDisplay() {
                const stars = document.querySelectorAll('.rating-stars .star-btn');
                stars.forEach((star, i) => {
                    if (i < this.currentLevelRating) {
                        star.classList.add('active');
                    } else {
                        star.classList.remove('active');
                    }
                });
            }

            updateGenerationDisplay() {
                const display = document.getElementById('generation-display');
                display.textContent = `Generation: ${this.population.generation} | Rated: ${this.ratedBots.length}`;
            }

            updateBotDisplay() {
                if (!this.currentBot) return;

                // Update curator info
                if (this.curatorBot) {
                    const curatorInfo = document.getElementById('curator-name');
                    curatorInfo.textContent = this.curatorBot.name;
                    curatorInfo.style.color = this.curatorBot.colors.primary;
                    curatorInfo.style.fontWeight = 'bold';
                }

                // Update creator bot name
                document.getElementById('bot-name').textContent = this.currentBot.name;

                // Update personality
                document.getElementById('bot-personality').textContent = this.currentBot.personality;

                // Draw creator bot sprite
                const canvas = document.getElementById('bot-sprite');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                this.currentBot.drawSprite(ctx, 40, 40, 70);
            }

            updatePopulationStats() {
                const stats = this.population.getStats();
                const display = document.getElementById('population-stats');
                display.style.display = 'block';
                display.innerHTML = `
                    <strong>Population Averages (Gen ${stats.generation}):</strong><br>
                    Grid: ${stats.averages.gridSize} |
                    Boxes: ${stats.averages.boxCount} |
                    Complexity: ${stats.averages.complexity} |
                    Density: ${stats.averages.wallDensity}
                `;

                // Update curation stats if available
                if (this.curationStats.length > 0) {
                    const avgAffinity = this.curationStats.reduce((sum, s) => sum + s.affinity, 0) / this.curationStats.length;
                    const curationDisplay = document.getElementById('curation-stats');
                    curationDisplay.style.display = 'block';
                    curationDisplay.innerHTML = `
                        Curations: ${this.curationStats.length} selections |
                        Avg affinity: ${(avgAffinity * 100).toFixed(1)}%
                    `;
                }
            }

            saveGenerationHistory() {
                const stats = this.population.getStats();
                this.generationHistory.push({
                    generation: stats.generation,
                    timestamp: Date.now(),
                    averages: stats.averages
                });
                this.savePersistentState();
            }

            savePersistentState() {
                const state = {
                    population: this.population.toJSON(),
                    generationHistory: this.generationHistory,
                    timestamp: Date.now()
                };
                localStorage.setItem('machinaLudensState', JSON.stringify(state));
            }

            loadState() {
                try {
                    const saved = localStorage.getItem('machinaLudensState');
                    if (!saved) return;

                    const state = JSON.parse(saved);
                    this.population = Population.fromJSON(state.population);
                    this.generationHistory = state.generationHistory || [];

                    console.log(`Loaded state: Generation ${this.population.generation}, ${this.generationHistory.length} history entries`);
                } catch (e) {
                    console.error('Failed to load saved state:', e);
                }
            }

            clearState() {
                if (confirm('Clear all evolution history and restart? This cannot be undone.')) {
                    localStorage.removeItem('machinaLudensState');
                    this.population = new Population(5);
                    this.generationHistory = [];
                    this.ratedBots = [];
                    this.currentLevelRating = 0;
                    this.updateGenerationDisplay();
                    this.updatePopulationStats();
                    alert('Evolution history cleared. Starting fresh!');
                    this.generateLevel();
                }
            }

            exportHistory() {
                const data = {
                    generationHistory: this.generationHistory,
                    currentGeneration: this.population.generation,
                    exportDate: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `machina-ludens-history-gen${this.population.generation}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            toggleHistoryView() {
                const historyView = document.getElementById('history-view');
                if (historyView.style.display === 'none') {
                    historyView.style.display = 'block';
                    this.renderHistoryTable();
                } else {
                    historyView.style.display = 'none';
                }
            }

            renderHistoryTable() {
                const content = document.getElementById('history-content');

                if (this.generationHistory.length === 0) {
                    content.innerHTML = '<p style="color: #666; font-style: italic;">No generation history yet. Breed your first generation to start tracking!</p>';
                    return;
                }

                let html = '<table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">';
                html += '<thead><tr style="border-bottom: 1px solid #444;">';
                html += '<th style="padding: 5px; text-align: left; color: #aaa;">Gen</th>';
                html += '<th style="padding: 5px; text-align: right; color: #aaa;">Grid</th>';
                html += '<th style="padding: 5px; text-align: right; color: #aaa;">Boxes</th>';
                html += '<th style="padding: 5px; text-align: right; color: #aaa;">Complex</th>';
                html += '<th style="padding: 5px; text-align: right; color: #aaa;">Density</th>';
                html += '</tr></thead><tbody>';

                this.generationHistory.forEach(entry => {
                    html += '<tr style="border-bottom: 1px solid #333;">';
                    html += `<td style="padding: 5px; color: #e0e0e0;">${entry.generation}</td>`;
                    html += `<td style="padding: 5px; text-align: right; color: #4ade80;">${entry.averages.gridSize}</td>`;
                    html += `<td style="padding: 5px; text-align: right; color: #60a5fa;">${entry.averages.boxCount}</td>`;
                    html += `<td style="padding: 5px; text-align: right; color: #fbbf24;">${entry.averages.complexity}</td>`;
                    html += `<td style="padding: 5px; text-align: right; color: #f87171;">${entry.averages.wallDensity}</td>`;
                    html += '</tr>';
                });

                html += '</tbody></table>';
                content.innerHTML = html;
            }

            saveExperiment() {
                const experimentName = prompt('Name this experiment (e.g., "Large Board Culture", "Dense Maze Preference"):', `Experiment-Gen${this.population.generation}`);
                if (!experimentName) return;

                const data = {
                    experimentName: experimentName,
                    population: this.population.toJSON(),
                    generationHistory: this.generationHistory,
                    savedDate: new Date().toISOString(),
                    currentGeneration: this.population.generation
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${experimentName.replace(/[^a-z0-9]/gi, '-').toLowerCase()}.json`;
                a.click();
                URL.revokeObjectURL(url);

                alert(`Experiment "${experimentName}" saved!\n\nYou can load this file later to continue the experiment.`);
            }

            loadExperiment(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);

                        if (!data.population || !data.generationHistory) {
                            alert('Invalid experiment file format!');
                            return;
                        }

                        if (this.population.generation > 0 || this.generationHistory.length > 0) {
                            if (!confirm('Loading this experiment will replace your current progress. Continue?')) {
                                return;
                            }
                        }

                        this.population = Population.fromJSON(data.population);
                        this.generationHistory = data.generationHistory;
                        this.ratedBots = [];
                        this.currentLevelRating = 0;

                        this.savePersistentState(); // Save to localStorage
                        this.updateGenerationDisplay();
                        this.updatePopulationStats();

                        alert(`Experiment "${data.experimentName || 'Unnamed'}" loaded!\n\nGeneration: ${this.population.generation}\nHistory entries: ${this.generationHistory.length}`);

                        this.generateLevel();
                    } catch (err) {
                        alert('Failed to load experiment: ' + err.message);
                        console.error(err);
                    }
                };
                reader.readAsText(file);

                // Reset the file input so the same file can be loaded again
                event.target.value = '';
            }

            breedNextGeneration() {
                if (this.ratedBots.length < 3) {
                    alert('Rate at least 3 levels before breeding!');
                    return;
                }

                // Build fitness array for current population
                // For genomes that were rated, use those ratings
                // For unrated genomes, use average rating
                const avgRating = this.ratedBots.reduce((sum, r) => sum + r.rating, 0) / this.ratedBots.length;

                const genomes = this.population.getCurrentGeneration();
                const fitnessScores = genomes.map(genome => {
                    // Find rating for this genome
                    const rated = this.ratedBots.find(r => r.genome === genome);
                    return rated ? rated.rating : avgRating * 0.5; // Unrated get half of average
                });

                // Evolve to next generation
                this.population.evolve(fitnessScores);

                // Save generation history
                this.saveGenerationHistory();

                // Reset rated bots for new generation
                this.ratedBots = [];
                this.currentLevelRating = 0;
                this.curationStats = []; // Reset curation stats for new generation
                this.updateRatingDisplay();
                this.updateGenerationDisplay();
                this.updatePopulationStats();

                // Hide breed button
                document.getElementById('breed-btn').classList.remove('visible');

                // Show stats
                const stats = this.population.getStats();
                alert(`Generation ${this.population.generation} created!\n\nAvg Grid Size: ${stats.averages.gridSize}\nAvg Boxes: ${stats.averages.boxCount}\nAvg Complexity: ${stats.averages.complexity}\nAvg Wall Density: ${stats.averages.wallDensity}`);
            }
        }

        // Initialize game
        const game = new Game();
    </script>
</body>
</html>
