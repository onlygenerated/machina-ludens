<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machina Ludens - Sokoban Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            margin-bottom: 30px;
            color: #888;
            font-style: italic;
        }

        #game-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        #canvas {
            display: block;
            background: #1a1a1a;
            border: 2px solid #444;
            image-rendering: pixelated;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        #touch-controls {
            display: none;
            margin-top: 20px;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        .dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
        }

        .dpad-btn {
            background: #3a3a3a;
            border: 2px solid #555;
            color: #e0e0e0;
            font-size: 24px;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }

        .dpad-btn:active {
            background: #4a4a4a;
            border-color: #777;
        }

        .dpad-up { grid-column: 2; grid-row: 1; }
        .dpad-down { grid-column: 2; grid-row: 3; }
        .dpad-left { grid-column: 1; grid-row: 2; }
        .dpad-right { grid-column: 3; grid-row: 2; }
        .dpad-center { grid-column: 2; grid-row: 2; opacity: 0; pointer-events: none; }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
            }

            #game-container {
                padding: 15px;
            }

            #touch-controls {
                display: flex;
            }

            button {
                padding: 10px 14px;
                font-size: 0.9em;
            }

            #controls {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }

            .instructions {
                font-size: 0.75em;
            }
        }

        #controls {
            margin-top: 20px;
            text-align: center;
        }

        .star-btn {
            background: #3a3a3a;
            border: 1px solid #555;
            color: #666;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 1.2em;
        }

        .star-btn.active {
            color: #fbbf24;
            background: #4a4a3a;
        }

        #info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #aaa;
        }

        #rating-panel {
            margin-top: 15px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 6px;
            border: 1px solid #444;
        }

        #rating-panel h3 {
            margin: 0 0 10px 0;
            font-size: 0.9em;
            color: #888;
            text-align: center;
        }

        .rating-stars {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 10px;
        }

        .rating-stars .star-btn {
            font-size: 1.5em;
            padding: 8px 12px;
        }

        #generation-display {
            text-align: center;
            color: #666;
            font-size: 0.85em;
            margin-top: 10px;
        }

        #breed-btn {
            display: none;
            margin-top: 10px;
            background: #5a3a5a;
            border-color: #8a6a8a;
        }

        #breed-btn.visible {
            display: inline-block;
        }

        button {
            background: #3a3a3a;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: #4a4a4a;
        }

        button:active {
            background: #2a2a2a;
        }

        #win-message {
            margin-top: 15px;
            font-size: 1.2em;
            color: #4ade80;
            text-align: center;
            min-height: 30px;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <h1>Machina Ludens</h1>
    <div class="subtitle">Sokoban Prototype</div>

    <div id="game-container">
        <div id="info">
            <div>Level: <span id="level-num">1</span></div>
            <div>Moves: <span id="move-count">0</span></div>
            <div>Pushes: <span id="push-count">0</span></div>
        </div>

        <canvas id="canvas" width="480" height="480"></canvas>

        <div id="win-message"></div>

        <div id="touch-controls">
            <div class="dpad">
                <div class="dpad-btn dpad-up" ontouchstart="game.handleTouch(0, -1)" ontouchend="event.preventDefault()">â¬†</div>
                <div class="dpad-btn dpad-left" ontouchstart="game.handleTouch(-1, 0)" ontouchend="event.preventDefault()">â¬…</div>
                <div class="dpad-center"></div>
                <div class="dpad-btn dpad-right" ontouchstart="game.handleTouch(1, 0)" ontouchend="event.preventDefault()">âž¡</div>
                <div class="dpad-btn dpad-down" ontouchstart="game.handleTouch(0, 1)" ontouchend="event.preventDefault()">â¬‡</div>
            </div>
        </div>

        <div id="controls">
            <button onclick="game.undo()">â†¶ Undo</button>
            <button onclick="game.reset()">âŸ² Reset</button>
            <button onclick="game.generateLevel()" style="background: #4a5a3a; border-color: #6a8a5a;">ðŸŽ² Generate</button>
        </div>

        <div id="win-message"></div>

        <div id="rating-panel">
            <h3>Rate this level</h3>
            <div class="rating-stars">
                <button class="star-btn" onclick="game.rateCurrentLevel(1)">â˜…</button>
                <button class="star-btn" onclick="game.rateCurrentLevel(2)">â˜…</button>
                <button class="star-btn" onclick="game.rateCurrentLevel(3)">â˜…</button>
                <button class="star-btn" onclick="game.rateCurrentLevel(4)">â˜…</button>
                <button class="star-btn" onclick="game.rateCurrentLevel(5)">â˜…</button>
            </div>
            <div id="generation-display">Generation: 0 | Rated: 0</div>
            <div style="text-align: center;">
                <button id="breed-btn" onclick="game.breedNextGeneration()">ðŸ§¬ Breed Next Generation</button>
            </div>
        </div>
    </div>

    <div class="instructions">
        Use Arrow Keys, WASD, or touch controls â€¢ Push all ðŸ“¦ onto ðŸŽ¯ to win
    </div>

    <script src="generator.js"></script>
    <script src="genome.js"></script>
    <script>
        // Game constants
        const TILE_SIZE = 60;
        const TILES = {
            FLOOR: 0,
            WALL: 1,
            TARGET: 2,
            BOX: 3,
            PLAYER: 4,
            BOX_ON_TARGET: 5
        };

        // Emoji rendering
        const EMOJI = {
            [TILES.FLOOR]: 'â¬›',
            [TILES.WALL]: 'ðŸŸ«',
            [TILES.TARGET]: 'ðŸŽ¯',
            [TILES.BOX]: 'ðŸ“¦',
            [TILES.PLAYER]: 'ðŸ‘¤',
            [TILES.BOX_ON_TARGET]: 'âœ…'
        };

        // Level data (1 = wall, 0 = floor, 2 = target, 3 = box, 4 = player)
        const LEVELS = [
            // Level 1: Tutorial
            {
                width: 7,
                height: 7,
                grid: [
                    1,1,1,1,1,1,1,
                    1,0,0,0,0,0,1,
                    1,0,0,3,0,0,1,
                    1,0,0,0,0,0,1,
                    1,0,4,0,2,0,1,
                    1,0,0,0,0,0,1,
                    1,1,1,1,1,1,1
                ]
            },
            // Level 2: Two boxes
            {
                width: 8,
                height: 7,
                grid: [
                    1,1,1,1,1,1,1,1,
                    1,0,0,0,0,0,0,1,
                    1,0,3,0,0,3,0,1,
                    1,0,0,0,0,0,0,1,
                    1,0,2,0,0,2,0,1,
                    1,0,0,4,0,0,0,1,
                    1,1,1,1,1,1,1,1
                ]
            },
            // Level 3: Corridor
            {
                width: 9,
                height: 5,
                grid: [
                    1,1,1,1,1,1,1,1,1,
                    1,4,0,3,0,3,0,0,1,
                    1,0,0,0,0,0,2,2,1,
                    1,0,0,0,0,0,0,0,1,
                    1,1,1,1,1,1,1,1,1
                ]
            },
            // Level 4: Classic puzzle
            {
                width: 7,
                height: 7,
                grid: [
                    1,1,1,1,1,1,1,
                    1,0,0,0,0,0,1,
                    1,0,3,1,3,0,1,
                    1,0,0,4,0,0,1,
                    1,0,2,1,2,0,1,
                    1,0,0,0,0,0,1,
                    1,1,1,1,1,1,1
                ]
            },
            // Level 5: Tight corners
            {
                width: 8,
                height: 8,
                grid: [
                    1,1,1,1,1,1,1,1,
                    1,2,0,0,0,0,2,1,
                    1,0,1,1,1,1,0,1,
                    1,0,1,0,0,1,0,1,
                    1,0,1,0,0,1,0,1,
                    1,0,1,1,1,1,0,1,
                    1,3,0,4,0,0,3,1,
                    1,1,1,1,1,1,1,1
                ]
            }
        ];

        // Game state
        class Game {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentLevel = 0;
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;

                // Breeding mode state
                this.population = new Population(5); // Start with initial population
                this.currentGenome = null; // Currently playing genome
                this.ratedGenomes = []; // Track rated genomes with their scores
                this.currentLevelRating = 0;

                this.setupControls();
                this.setupTouchGestures();

                // Generate first level automatically
                this.generateLevel();
            }

            handleTouch(dx, dy) {
                if (this.won) return;
                this.move(dx, dy);
            }

            setupTouchGestures() {
                let touchStartX = 0;
                let touchStartY = 0;
                const minSwipeDistance = 30;

                this.canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    e.preventDefault();
                }, { passive: false });

                this.canvas.addEventListener('touchend', (e) => {
                    if (this.won) return;

                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;

                    const absX = Math.abs(deltaX);
                    const absY = Math.abs(deltaY);

                    if (absX < minSwipeDistance && absY < minSwipeDistance) {
                        return;
                    }

                    if (absX > absY) {
                        this.move(deltaX > 0 ? 1 : -1, 0);
                    } else {
                        this.move(0, deltaY > 0 ? 1 : -1);
                    }

                    e.preventDefault();
                }, { passive: false });
            }

            loadLevel(levelNum) {
                if (levelNum >= LEVELS.length) {
                    this.showWin("ðŸŽ‰ All levels complete! ðŸŽ‰");
                    return;
                }

                this.currentLevel = levelNum;
                const level = LEVELS[levelNum];
                this.width = level.width;
                this.height = level.height;
                this.grid = [...level.grid];
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;

                // Find player position
                const playerIdx = this.grid.indexOf(TILES.PLAYER);
                this.playerX = playerIdx % this.width;
                this.playerY = Math.floor(playerIdx / this.width);

                // Update canvas size
                this.canvas.width = this.width * TILE_SIZE;
                this.canvas.height = this.height * TILE_SIZE;

                this.updateUI();
                this.render();
            }

            reset() {
                this.loadLevel(this.currentLevel);
            }

            nextLevel() {
                this.loadLevel(this.currentLevel + 1);
            }

            generateLevel() {
                // Pick a random genome from current population
                const genomes = this.population.getCurrentGeneration();
                this.currentGenome = genomes[Math.floor(Math.random() * genomes.length)];

                // Generate level from this genome
                const generatedLevel = this.currentGenome.generateLevel();

                // Load it as a custom level
                this.currentLevel = -1; // Mark as generated
                this.width = generatedLevel.width;
                this.height = generatedLevel.height;
                this.grid = generatedLevel.grid;
                this.playerX = generatedLevel.playerX;
                this.playerY = generatedLevel.playerY;
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.won = false;
                this.currentLevelRating = 0;

                // Update canvas size
                this.canvas.width = this.width * TILE_SIZE;
                this.canvas.height = this.height * TILE_SIZE;

                this.updateUI();
                this.render();
                this.updateRatingDisplay();
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.won) return;

                    const key = e.key.toLowerCase();

                    if (key === 'z') {
                        this.undo();
                        e.preventDefault();
                    } else if (key === 'r') {
                        this.reset();
                        e.preventDefault();
                    } else if (key === 'n') {
                        this.nextLevel();
                        e.preventDefault();
                    } else {
                        const moves = {
                            'arrowup': [0, -1],
                            'arrowdown': [0, 1],
                            'arrowleft': [-1, 0],
                            'arrowright': [1, 0],
                            'w': [0, -1],
                            's': [0, 1],
                            'a': [-1, 0],
                            'd': [1, 0]
                        };

                        if (moves[key]) {
                            this.move(...moves[key]);
                            e.preventDefault();
                        }
                    }
                });
            }

            move(dx, dy) {
                const newX = this.playerX + dx;
                const newY = this.playerY + dy;

                if (!this.isValid(newX, newY)) return;

                const targetTile = this.getTile(newX, newY);

                // Hit a wall
                if (targetTile === TILES.WALL) return;

                // Save state for undo
                this.saveState();

                // Check if pushing a box
                if (targetTile === TILES.BOX || targetTile === TILES.BOX_ON_TARGET) {
                    const boxNewX = newX + dx;
                    const boxNewY = newY + dy;

                    if (!this.isValid(boxNewX, boxNewY)) return;

                    const boxTargetTile = this.getTile(boxNewX, boxNewY);

                    // Can't push into wall or another box
                    if (boxTargetTile === TILES.WALL ||
                        boxTargetTile === TILES.BOX ||
                        boxTargetTile === TILES.BOX_ON_TARGET) {
                        this.history.pop(); // Undo the save
                        return;
                    }

                    // Move the box
                    const isOnTarget = boxTargetTile === TILES.TARGET;
                    this.setTile(boxNewX, boxNewY, isOnTarget ? TILES.BOX_ON_TARGET : TILES.BOX);
                    this.pushes++;
                }

                // Clear old player position (restore target if needed)
                const wasOnTarget = this.getTile(this.playerX, this.playerY) === TILES.TARGET;
                this.setTile(this.playerX, this.playerY, wasOnTarget ? TILES.TARGET : TILES.FLOOR);

                // Clear box from new player position if present
                const movingToTarget = targetTile === TILES.TARGET || targetTile === TILES.BOX_ON_TARGET;

                // Move player
                this.playerX = newX;
                this.playerY = newY;
                this.setTile(newX, newY, movingToTarget ? TILES.TARGET : TILES.FLOOR);

                this.moves++;
                this.updateUI();
                this.render();
                this.checkWin();
            }

            undo() {
                if (this.history.length === 0) return;

                const state = this.history.pop();
                this.grid = state.grid;
                this.playerX = state.playerX;
                this.playerY = state.playerY;
                this.moves = state.moves;
                this.pushes = state.pushes;

                this.updateUI();
                this.render();
            }

            saveState() {
                this.history.push({
                    grid: [...this.grid],
                    playerX: this.playerX,
                    playerY: this.playerY,
                    moves: this.moves,
                    pushes: this.pushes
                });
            }

            isValid(x, y) {
                return x >= 0 && x < this.width && y >= 0 && y < this.height;
            }

            getTile(x, y) {
                return this.grid[y * this.width + x];
            }

            setTile(x, y, tile) {
                this.grid[y * this.width + x] = tile;
            }

            checkWin() {
                // Check if all boxes are on targets
                const hasLooseBox = this.grid.some(tile => tile === TILES.BOX);

                if (!hasLooseBox) {
                    this.won = true;
                    this.showWin("Level Complete! ðŸŽ‰");
                }
            }

            showWin(message) {
                document.getElementById('win-message').textContent = message;
            }

            updateUI() {
                const levelText = this.currentLevel === -1 ? 'Generated' : this.currentLevel + 1;
                document.getElementById('level-num').textContent = levelText;
                document.getElementById('move-count').textContent = this.moves;
                document.getElementById('push-count').textContent = this.pushes;
                document.getElementById('win-message').textContent = '';
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.font = `${TILE_SIZE - 10}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';

                // Draw grid
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.getTile(x, y);
                        const emoji = EMOJI[tile];

                        const px = x * TILE_SIZE + TILE_SIZE / 2;
                        const py = y * TILE_SIZE + TILE_SIZE / 2;

                        this.ctx.fillText(emoji, px, py);
                    }
                }

                // Draw player on top
                const px = this.playerX * TILE_SIZE + TILE_SIZE / 2;
                const py = this.playerY * TILE_SIZE + TILE_SIZE / 2;
                this.ctx.fillText(EMOJI[TILES.PLAYER], px, py);
            }

            // === BREEDING MODE METHODS ===

            rateCurrentLevel(rating) {
                if (!this.currentGenome) {
                    alert('Generate a level first!');
                    return;
                }

                this.currentLevelRating = rating;

                // Store this rating
                this.ratedGenomes.push({
                    genome: this.currentGenome,
                    rating: rating
                });

                // Update star display
                this.updateRatingDisplay();

                // Update generation display
                this.updateGenerationDisplay();

                // Show breed button if we have enough ratings
                if (this.ratedGenomes.length >= 3) {
                    document.getElementById('breed-btn').classList.add('visible');
                }
            }

            updateRatingDisplay() {
                const stars = document.querySelectorAll('.rating-stars .star-btn');
                stars.forEach((star, i) => {
                    if (i < this.currentLevelRating) {
                        star.classList.add('active');
                    } else {
                        star.classList.remove('active');
                    }
                });
            }

            updateGenerationDisplay() {
                const display = document.getElementById('generation-display');
                display.textContent = `Generation: ${this.population.generation} | Rated: ${this.ratedGenomes.length}`;
            }

            breedNextGeneration() {
                if (this.ratedGenomes.length < 3) {
                    alert('Rate at least 3 levels before breeding!');
                    return;
                }

                // Build fitness array for current population
                // For genomes that were rated, use those ratings
                // For unrated genomes, use average rating
                const avgRating = this.ratedGenomes.reduce((sum, r) => sum + r.rating, 0) / this.ratedGenomes.length;

                const genomes = this.population.getCurrentGeneration();
                const fitnessScores = genomes.map(genome => {
                    // Find rating for this genome
                    const rated = this.ratedGenomes.find(r => r.genome === genome);
                    return rated ? rated.rating : avgRating * 0.5; // Unrated get half of average
                });

                // Evolve to next generation
                this.population.evolve(fitnessScores);

                // Reset rated genomes for new generation
                this.ratedGenomes = [];
                this.currentLevelRating = 0;
                this.updateRatingDisplay();
                this.updateGenerationDisplay();

                // Hide breed button
                document.getElementById('breed-btn').classList.remove('visible');

                // Show stats
                const stats = this.population.getStats();
                alert(`Generation ${this.population.generation} created!\n\nAvg Grid Size: ${stats.averages.gridSize}\nAvg Boxes: ${stats.averages.boxCount}\nAvg Complexity: ${stats.averages.complexity}\nAvg Wall Density: ${stats.averages.wallDensity}`);
            }
        }

        // Initialize game
        const game = new Game();
    </script>
</body>
</html>
